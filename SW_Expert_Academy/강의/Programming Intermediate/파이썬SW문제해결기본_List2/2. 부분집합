부분집합의 합
    - 유한 개의 정수로 이루어진 집합이 있을 때, 이 집합의 부분 집합 중에서 그 집합의 원소를 모두 더한 값이 0이 되는 경우가 있는지를 알아내는 문제
    - 완전 검색기법으로 부분집합의 합 문제를 풀기 위해서는
      우선 집합의 모든 부분 집합을 생성한 후 각 부분 집합의 합을 계산함
    - 주어진 집합의 부분 집합을 생성하는 방법 생각하기 

부분집합의 수
    - 어떤 부분 집합을 구할 경우 부분 집합의 총 개수를 구하려면?
    - 전체 집합의 각 원소를 부분집합에 포함시키거나(1) 시키지 않거나(0)의 각 2가지 경우씩이 있으므로, 원소의 개수를 n이라 할때 부분집합의 개수는 공집합과 전체집합을 포함하여 2의 n제곱(개)이다.

    ex) Loop를 이용하여 확인하고, 부분 집합을 생성하는 방법
        bit = [0,0,0,0]
        for i in range(2):
            bit[0] = i
            for j in range(2):
                bit[1] = j
                for k in range(2):
                    bit[2] = k
                    for l in range(2):
                        bit[3] = l
                        print(bit) ==> 전체 집합list의 각 원소를 포함할지 말지를 정하는 list

        가령, bit = [1,1,1,1]이면 원 집합의 4개의 원소를 모두 포함시키는 부분집합을 만들겠다는 소리다.
    
비트 연산자
    : 0 과 1로 이루어진 이진수에 대한 연산을 수행하는 연산자
    & : 두 값의 각 자리수를 비교하여 둘다 1이 있을 경우만 1, 나머지는 0을 반환
    | : 두 값의 각 자리수를 비교하여 어느 하나에라도 1이 있을 경우 1, 나머지는 0을 반환
    << : 피연산자의 비트 열을 왼쪽으로 이동 시킴 
    >> : 피연산자의 비트 열을 오른쪽으로 이동 시킴

    1 << n : 2의 n 제곱 ===> 원소가 n개일 경우의 모든 부분 집합의 수 의미
    i & (1 << j): 1 ===> i에서 j번째 비트가 1인지 아닌지를 리턴함

보다 간결하게 부분집합을 생성하는 법
    arr = [3,6,7,1,5,4]
    n = len(arr)  # n:원소의 개수

    for i in range(1<<n): #1<<n는 2의 n제곱으로 부분집합의 개수를 의미한다.
        for j in range(n): #원소의 수만큼 비트를 비교함
            if i&(1<<j): i번째 부분집합의 j번째 원소의 포함 여부를 판단
                print(arr[j], end=',')
        print() #부분집합별로 서로 다른 줄로 나누기
