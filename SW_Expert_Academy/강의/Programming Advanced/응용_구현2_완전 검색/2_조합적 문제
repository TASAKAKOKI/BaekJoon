완전검색과 조합적 문제
    - 많은 종류의 실세계 문제들이 특정 조건을 만족하는 경우나 요소를 찾는 검색
    - 순열(Permutation), 조합(Combination),부분집합(Subset)과 같은 조합적 문제들(Combinatorial Problems)과 관련
    - 완전검색: 조합적 문제에 대한 고지식한 방법(Brute-force)
순열
    서로 다른 것들 중 몇 개를 뽑아서 한 줄로 나열하는 것
    - 서로 다른 n개 중 r개를 택하는 순열: nPr
    - nPr의 식 성립: n * (n-1) * (n-1) * .... * (n-r+1)
        : n!/(n-r)!
    - nPn = n!라고 표기하며, n Factorial이라 부름
    ex) {1,2,3,4}로 순열 생성
        순열의 수: 4!인 24.
        깊이가 4이고, 단말노드의 개수가 24인 트리구조.
    -다수의 알고리즘 문제들:::
        -순서화된 요소들의 집합에서 최선의 방법을 찾는 것과 관련
        ex)순회 외판원 문제:
            - 여러 도시들이 있고 한 도시에서 다른 도시로 이동하는 비용이 모두 주어짐
            - 출발 도시에서 시작해서 다른 모든 도시들을 단 한 번만 방문하고 출발 도시로 돌아오는 최소 비용의 이동경로를 구하는 문제
            - 방문할 도시들을 순서대로 나열하면 하나의 경로가 됨
    - N개의 요소들에 대해서 n!개의 순열들이 존재
        - 순회 외판원 문제에서 거쳐가야 할 도시가 n개라면 가능한 모든 경로는 n!만큼 존재! (가령, 12개의 도시를 방문해야 한다면... 12! = 479,001,600)
    ==>N의 값이 증가할 수록, N!의 값은 기하급수적으로 증가하므로 현실적으로 순열 생성하여 완전검색하는 것은 바람직하지 않음.

    -순설 생성 방법
        - 사전식 순서(Lexicographic-Order)
            - 요소들이 오름차순으로 나열된 형태가 시작하는 하나의 순열 
            - {1,2,3},n = 3인 경우
                = [1 2 3] [1 3 2] [2 1 3] [2 3 1] [3 1 2] [3 2 1]
        - 최소 변경을 통한 방법(Minimun-exchange requirement)
            - 각각의 순열들은 이전의 상태에서 단지 두 개의 요소들을 교환 함으로서 생성
            - {1,2,3} 순열에서 1과 3을 교환해서 {3,2,1} 순열을 만듦
                = [1 2 3] [3 2 1] [2 3 1] [2 1 3] [3 1 2] [1 3 2]
        <최소한의 변경(Minimn-change requirement)을 통해 순열을 생성하는 방법> 
            -Johnson-Trotter알고리즘
        - 두 원소의 교ㅛ환을 통해 생성
            - N개의 요소가 있을 때 N번의 선택으로 순열 생성
    -파이썬에서 라이브러리를 활용하여 순열 사용하기
        import itertools
        mylist = [1,2,3]
        result = itertools.permutations(mylist,r) # (myist,3)
                                # 뽑을 갯수, r 생략시, 기본값은 리스트의 크기.
        print(list(result)) #또는 반복문으로 출력 가능

    - 파이썬의 라이브러리를 활용한 중복 순열
        import itertools
        mylist = [1,2,3]
        result = itertools.product(mylist,repeat = 3) 
        print(list(result)) #또는 반복문으로 출력 가능

부분집합
    - 집합에 포함된 원소들을 선택하는 것
    - 다수의 중요 알고리즘들이 원소들의 그룹에서 최적의 부분집합을 찾는 것
        <배낭에 짐싸기 문제(Knapsack Problem)>
            - 배낭과 물건들의 집합이 주어지며, 배낭은 무게가 있고, 각 아이템들은 각각 무게와 가치가 있음
            - 배낭에 담는 무게의 총합 < 배낭의 무게
            - 물건의 총합이 배낭의 무게를 초과하지 않으면서 가치의 합이 최대가 되는 물건들을 선택하는 문제
        ==> 동적계획법, 탐욕기법을 배울 때 추가 학습
    - N개의 원소를 포함한 집합
        - 자기 자신과 공집합을 포함한  모든 부분집합(Power set)의 개수는 2^n개 
    <단순하게 모든 부분집합 생성하는 방법>
        - 4개 원소를 포함한 집합에 대한 Power set 구하는 법
        arr = [2,3,4,5] #실제 집합
        bit = [0] *len(arr) #주어진 집합의 원소의 개수만큼의 bit를 생성
        for i in range(2): #포함, 미포함의 2가지 경우를 각각의 원소에 적용할 예정
            bit[0] = i      #0번째 원소
            for j in range(2):
                bit[1] = j  #1번째 원소
                for k i range(2):
                    bit[2] = k #2번쨰 원소
                    for l in range(2):
                        bit[3] = l #3번째 원소
                        print([arr[x] for x in range(len(bit)) if bit[x]]) 생성된 부분집합을 출력, bit[x]가 0이 아닌 경우(즉 1인 경우)일때만, arr의 x번째 원소를 부분집합에 포함하여 출력
    -<비트표현을 이용해서 부분집합을 생성하는 간단한 방법>
        -바이너리 카운팅(Binary counting)을 통한 사전적 순서(Lexicographic Order)
            -부분집합을 생성하기 위한 가장 자연스럽고 간단한 방법
            -바이너리 카운팅(Binary Counting)은 사전적 순서로 생성하기 위한 가장 간단한 방법
       -바이너리 카운팅(Binary Counting)
            -원소 수에 해당하는 N개의 비트 열을 이용
            -i번째 비트 값이 1이면 i번째 원소가 포함되었음을 의미
            (0<=i<=N -1)
            인덱스(i) 0  1  2  3
            값        A  B  C  D
            모든 부분집합의 개수는 2^4인 16개

            ex) 10진수  이진수  {A,B,C,D}
                 0      0000    {}
                 1      0001    {A}
                 2      0010    {B}
                 3      0011    {B,A}
                 4      0100    {C}
                 5      0101    {C,A}
                 6      0110    {C,B}
                 7      0111    {C,B,A}
                 8      1000    {D}
                 9      1001    {D,A}
                 10     1010    {D,B}
                 11     1011    {D,B,A}
                 12     1100    {D,C}
                 13     1101    {D,C,A}
                 14     1110    {D,C,B}
                 15     1111    {D,C,B,A}
            <바이너리 카운팅을 통한 부분집합 생성코드>
            1_
                arr = [2,3,4,5]
                n = len(arr) #n:arr의 원소의 개수

                for i in range(1<<n): #1<<n은 부분집합의 개수를 의미
                    for j in range(n): #원소의 수만큼 비트를 비교함
                        if i &(i<<j): #i의 j번째 비트가 1이면 j번째 원소를 출력
                            print(arr[j],end=',')
                        print()
            2_ 리스트의 함축을 이용
                arr = [2,3,4,5]
                for i in range(1<<len(arr)):
                    print([arr[j] for j in range(len(arr)) if i&(1<<j)])
조합
    : 서로다른 n개의 원소 중 r개를 순서 없이 골라낸 것
    조합의 수식:
    nCr = n! /  (n-r)!*r! (n>=r)
    nC0 = 1 = nCn
    nCr = nC(n-r)
    nCr = (n-1)C(r-1)+(n-1)Cr  // 재귀적 표현

    재귀적 정의의 표현
    즉, 5개중 3개를 뽑는 5C3의 경우는, 4개중에서 2개를 뽑는 경우와 4개 중에서 3개를 뽑는 경우의 합(4C2+ 4C3)과 같음.
        ex) 임의의 요소 (n)를 제외한다.
            이때 5개에서 3개를 선택하는 모든 경우는 
            임의의 요소(n)를 포함하는 경우와 포함하지 않는 경우로 나눌 수 있음
            n을 반드시 포함하는 경우는 남은 4개의 원소들 중 2개를 고르는 경우와 같고,
            n을 반드시 포함하지 않는 경우는 남은 4개의 원소들 중 3개를 고르는 경우와 같으므로, 식이 성립
    <재귀 호출을 이용한 조합 생성 알고리즘>
        #an[]: n개의 원소를 가지고 있는 리스트
        #tr[]: 조합이 임시 저장될 r개의 크기의 리스트

        def comb(n,r): #n:전체 원소의 개수, r뽑을 개수
            if r == 0 : print(tr) # 조합의 하나의 경우가 완성된 것.
            elif n < r: return
            else:
                tr[r-1] = an[n-1]
                comb(n-1,r-1)
                comb(n-1,r)
    - 파이썬의 라이브러리를 활용한 조합
            import itertools
            mylist = [1,2,3]
            result = itertools.combinations(mylist,r = 2) # r(뽑을 갯수)생략불가 
            print(list(result)) #또는 반복문으로 출력 가능
    - 파이썬의 라이브러리를 활용한 중복조합
            import itertools
            mylist = [1,2,3]
            result = itertools.combinations_with_replacement(mylist,r = 2) # r(뽑을 갯수)생략불가 
            print(list(result)) #또는 반복문으로 출력 가능
  
